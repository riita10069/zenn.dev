# 7.4 Closed-Loop SiL アーキテクチャ

この節では、Closed-Loop SiL (Software-in-the-Loop) アーキテクチャについて解説します。センサシミュレーション・物理シミュレーション・トラフィックシミュレーション、モデルとシミュレータのインターフェース設計、大量シナリオバッチ実行基盤を整理し、データ中心・Closed-Loop の観点から「シミュレーション結果をどのようにデータエンジンに戻すか」を考えます。

## SiL の位置づけと目的

Software-in-the-Loop (SiL) は、実 ECU や実車を用いず、ソフトウェアのみを仮想環境上で実行する評価形態です。一般的には、以下のような目的で活用されます。

- 開発初期から高頻度で Closed-Loop 評価を行い、設計上の問題を早期に検知する。
- 多数のシナリオを並列に実行し、カバレッジを効率的に向上させる。
- 危険なシナリオや現実には再現が難しい条件（極端な天候、センサ故障など）を安全に検証する。

SiL は、実 ECU を用いる HiL と比べるとタイミング精度やハードウェア依存の挙動再現性では劣ることが多い一方で、柔軟性とスケーラビリティに優れています。データ中心・Closed-Loop の観点では、「データエンジンに密接に結び付いた高速な Closed-Loop 評価レイヤ」としての役割を担うことが多いです。

## センサシミュレーション・物理シミュレーション

SiL アーキテクチャの中核はセンサシミュレーション (sensor simulation) と物理シミュレーション (physics simulation) です。代表的な要素は次の通りです。

- 3D ワールド表現:
  - HD マップや 3D アセット（建物、標識、車両）を用いた環境モデル。
  - 時間変化するオブジェクト（他車・歩行者・信号機）の状態遷移。
- センサモデル:
  - カメラ: 投影モデル、レンズ歪み、露出、ノイズ、モーションブラー。
  - LiDAR: レイトレーシングによる距離・反射強度計算、ビームパターン、ノイズ。
  - Radar: 速度分解能、マルチパス、クラッタの近似モデル。
- 車両ダイナミクス:
  - 車両運動方程式、タイヤモデル、制御遅延、アクチュエータ飽和。

これらをどの程度精密にモデル化するかは、目的とコストのトレードオフになります。例えば、Perception モデルのロバスト性検証が主目的であれば、光学的に忠実なレンダリングが重要になる一方、Planning の高レベル戦略検証であれば、センサモデルは簡略化し、交通参加者の挙動モデルに計算資源を割く、といった設計が考えられます。

## トラフィックシミュレーションとシナリオ実行エンジン

トラフィックシミュレーション (traffic simulation) は、他車両・歩行者・自転車などのエージェントの挙動をモデル化するコンポーネントです。代表的なアプローチとして、

- ルールベースモデル（車頭追従モデル、車線変更モデルなど）
- マルチエージェントシミュレーション（エージェント間の相互作用を考慮）
- 実ログから学習したポリシーに基づく挙動モデル

などがあります。トラフィックシミュレーションは、OpenSCENARIO 等のシナリオ定義から初期条件・意図・制約を受け取り、時間ステップごとに他エージェントの行動を更新します。

SiL アーキテクチャでは、トラフィックシミュレータと自動運転スタックの間で以下のようなループが回ります。

1. 時刻 $t$ におけるワールド状態（位置・速度・信号状態など）からセンサデータを生成。
2. センサデータを自動運転スタックに入力し、出力（コマンド、計画軌道など）を得る。
3. その出力を車両ダイナミクスモデルに適用し、自車の次状態を計算。
4. 他エージェントのポリシーに基づき、他車・歩行者の次状態を計算。
5. $t+1$ に進め、終了条件に達するまで繰り返す。

この Closed-Loop を安定して高速に回すには、時間同期とインターフェース設計が重要になります。

## モデルとシミュレータのインターフェース設計

モデルとシミュレータのインターフェースには、少なくとも次のような設計ポイントがあります。

- 通信方式:
  - 同一プロセス内での関数呼び出し（最も高速だが柔軟性は低い）。
  - IPC / RPC（例: gRPC, shared memory, ZeroMQ）を用いたプロセス間通信。
  - ROS / DDS などのミドルウェアを介した pub/sub 通信。
- 時刻同期:
  - シミュレータ側が「マスタ」となり、各タイムステップでモデルに処理時間を割り当てる同期型。
  - モデル側が非同期に動作し、センサバッファとコマンドバッファを介して擬似的なリアルタイムを再現する方式。
- メッセージ仕様:
  - センサデータ（画像、点群、CAN 信号など）のフォーマット。
  - コマンド（加減速、ステアリング、インジケータなど）の表現。
  - メタデータ（シナリオ ID、ラン ID、乱数シードなど）の付与。

データ中心・Closed-Loop の観点では、このインターフェースに「評価用メタデータ」を組み込んでおくことが重要です。たとえば、各タイムステップにシナリオ ID・タイムスタンプ・モデルバージョン・シミュレータ設定 ID を付与しておくことで、後段のレポート生成や失敗ケース解析が容易になります。

## 大量シナリオバッチ実行基盤

SiL の強みを活かすには、大量のシナリオを自動的にスケジューリングして実行するバッチ基盤が不可欠です。典型的な構成要素は次の通りです。

- ジョブスケジューラ:
  - シナリオ ID のリストとモデルバージョンを入力として受け取り、クラスタ上の計算リソースにジョブを配分する。
  - 優先度キューやフェアシェアなどのポリシーを実装する。
- 実行コンテナ:
  - 自動運転スタックとシミュレータを含むコンテナイメージを用意し、環境差異を最小化する。
  - 実行中のログ（センサ、コマンド、内部状態、メトリクス）をストレージにストリーミングする。
- 結果集計・レポート:
  - シナリオ単位・ODD セグメント単位での指標を自動集計し、第 7.8 節で扱うレポート生成基盤に渡す。

この基盤が第 6 章で扱ったトレーニングパイプラインと同じオーケストレーション基盤（ワークフローエンジンなど）上に構築されていると、モデル更新 → シミュレーション評価 → レポート生成 → リリース判定までを「パイプライン as Code」として管理しやすくなります。

## シミュレーション結果をデータエンジンに戻す

最後に、SiL の結果をデータ中心・Closed-Loop のデータエンジンにどのように戻すかを整理します。

- 失敗ケースの抽出:
  - 衝突・ニアミス・フェイルセーフ作動などのイベントを自動検出し、シナリオ DB に紐付けて記録する。
  - 失敗時のセンサログ・中間表現（BEV 特徴、世界モデル状態など）をデータレイクに保存する。
- データ選択・ラベリングへのフィードバック:
  - 失敗シナリオに類似した実車ログを検索し、第 4 章のデータ選択パイプラインに渡す。
  - 必要に応じて追加ラベリングや品質向上を行い、第 5 章のラベリングパイプラインに流し込む。
- モデル学習・評価への統合:
  - シミュレーション由来のデータをトレーニングデータセットに含めるかどうか、どの割合で含めるかを設計する。
  - 改良版モデルに対して同じシナリオセットで再評価し、改善度と副作用（他シナリオでの性能低下）を確認する。

このように、Closed-Loop SiL アーキテクチャは、「評価のためのシミュレータ」ではなく、「データ中心・Closed-Loop データエンジンの一部」として設計することが重要です。
