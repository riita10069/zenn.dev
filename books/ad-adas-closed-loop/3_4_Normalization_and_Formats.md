# 3.4 データ正規化とフォーマット設計

この節では、クラウド側でのデータ正規化 (data normalization) とフォーマット設計について、実務で用いられる具体的なツールやフォーマットに踏み込みながら解説します。ROS / WebDataset などの共通フォーマットへの変換、バイナリデータとメタデータの分離、drive / scene / sample 単位のファイルレイアウト、画像・点群・CAN ログの圧縮方式などを整理します。  
データ中心・Closed-Loop の観点では、「一度正規化されたフォーマットが、第 4 章以降のシーン検索・データ選択・ラベリング・学習・シミュレーション・運用モニタリングのすべてで共通の土台になる」ことが重要です。本節で設計したフォーマットの良し悪しが、後段の改善サイクル全体のスピードとコストを大きく左右します。

---

## ROS / WebDataset 化とバイナリ・メタデータ分離

### ロガー固有フォーマットから共通フォーマットへ

車載ロガーは、メーカーごとに独自のフォーマット（独自バイナリ、PCAP、動画コンテナ、ベンダー固有の CAN ログ形式など）を採用していることが多いです。このままでは解析・学習基盤側での再利用性が低く、ロガーごと・世代ごとに専用デコーダを維持する必要が生じます。  
そのためクラウド側では、まず「共通フォーマット」への正規化レイヤを用意することが多いです。ロボティクス・自動運転分野でよく採用される代表的なフォーマットが、ROS bag（ROS 1）および rosbag2（ROS 2）、そして大規模学習向けの WebDataset です。

### ROS bag / rosbag2 を中間フォーマットとして用いる

ROS bag は、ROS (Robot Operating System) のメッセージを「トピックごとの時系列メッセージ列」として保存するフォーマットです。ROS 1 では `.bag` ファイルにすべてのメッセージが格納され、`rosbag record` / `rosbag play` コマンドで記録・再生を行います。  
ROS 2 では rosbag2 と呼ばれる後継実装が用意され、`ros2 bag record` / `ros2 bag play` コマンドで操作します。rosbag2 はプラグイン方式のストレージ層を持ち、デフォルトのストレージとして SQLite3 ベースの `.db3` ファイル（`rosbag2_storage_sqlite3`）や MCAP (MCAP storage plugin) を利用できます。メタデータは `metadata.yaml` に保存され、記録されたトピック名や型、QoS 設定、ストレージファイルのパスなどを記述します。

rosbag2 では CLI オプションでストレージ形式・圧縮方式・ファイル分割戦略などを柔軟に指定できます。例えば、全トピックを zstd 圧縮付きで記録する場合は次のようなコマンドになります。

```bash
ros2 bag record -a \
  --storage mcap \
  --compression-mode file \
  --compression-format zstd
```

このような「ROS トピックとして正規化されたログ」は、シミュレーション（第 7 章）やローカルデバッグ、可視化ツール（RViz / Foxglove Studio 等）の入力として扱いやすくなります。また、ロボティクス系のツールチェーンをそのまま流用できるため、早期のプロトタイピングにも向いています。  
一方で、フリート全体で数十ペタバイト以上を扱うスケールでは、rosbag2 そのものをクラウド側の最終形式とするよりも、「ロガー → rosbag2 → 学習・分析向けフォーマット（後述の WebDataset 等）」という多段構成を採ることが多いです。

### WebDataset による大規模学習向け正規化

WebDataset は、深層学習向けの大規模データセットを tar アーカイブとしてシャーディングするフォーマットです。各 tar ファイル（シャード）は `something-000000.tar` のように連番を持ち、その中には同じベースネームを共有するファイル群（例: `12345.jpg`, `12345.json`, `12345.bin`）が 1 サンプルを構成します。
PyTorch では、専用ライブラリや `torchdata.datapipes.iter.WebDataset` といった DataPipe を用いて、tar から逐次サンプルを読み込み、GPU トレーニングに供給できます。tar は連続アクセスに適しており、クラウドオブジェクトストレージ（S3 互換など）上でも高いスループットを出しやすいという利点があります。

WebDataset への正規化では、例えば次のような設計が考えられます。

- 画像認識モデル用: `sample_id.jpg`（カメラ画像）、`sample_id.json`（ラベルやメタデータ）、`sample_id.meta`（内部用メタ情報）  
- BEV / LiDAR モデル用: `sample_id.lidar.bin`（正規化済み点群）、`sample_id.cam.jpg`（カメラ画像）、`sample_id.pose.json`（車両姿勢・キャリブ情報）  
- シーケンスモデル用: `sample_id.seq.npz`（N フレーム分をまとめたシーケンス）と `sample_id.seq.json`（シナリオ情報）

学習ジョブ側では、ファイルパターン `s3://bucket/train-{000000..000999}.tar` のような URL を指定し、WebDataset/torchdata を通じてストリーミング読み出しを行います。  
このような「学習向けフォーマット」への正規化は、第 6 章のトレーニングパイプライン設計と直結します。重要なのは、ストレージ階層や学習クラスタの構成に合わせて、シャードサイズ・ファイル数・キー設計をチューニングすることです（例: 1 シャードあたり数千サンプル、各 GPU ジョブが複数シャードを順次処理できるようにする等）。

### バイナリデータとメタデータの分離

ROS bag / WebDataset いずれを採用する場合でも、「バイナリデータ（画像・点群・センサ波形など）とメタデータ（タイムスタンプ、センサー ID、ODD 属性、ラベル状態など）を論理的に分離する」設計が重要です。  
バイナリデータはオブジェクトストレージやファイルシステム上に保持し、メタデータはパーケット (Parquet) や列指向データベース、あるいは専用のメタデータカタログ（3.7 節）に保存するパターンが多いです。

メタデータには、少なくとも次のような情報を含めておくことが望ましいです。

- `drive_id` / `scene_id` / `frame_id` / `sample_id` などの階層的 ID  
- 車両情報（車種、VIN、ハードウェア構成）、ソフトウェアバージョン、センサー構成 ID  
- ODD 関連属性（地域、路線 ID、天候、時間帯、道路種別、交通量セグメントなど）  
- ラベル状態（未ラベル / 一次ラベル済み / 監査済み / 再ラベル予定）、ラベルバージョン  
- 格納形式・圧縮方式・解像度・センサ設定（露出、フレームレート、レンジ等）

実際のクエリパターンを想定すると、「メタデータクエリで候補サンプルを数百万件 → そこから数千〜数万件をランダム抽出 → 対応するバイナリだけを読み出す」といったワークフローが多くなります。  
正規化フェーズでメタデータを十分に設計しておくことで、第 4 章のシーン検索 UI、アクティブラーニング、第 5 章のラベリング計画、第 6 章のデータセット設計までを、一貫したキーとクエリで繋ぎやすくなります。

---


## 圧縮方式（画像・点群・CAN ログ etc.）

圧縮方式の選択は、ストレージコスト・デコード速度・実装の複雑さのトレードオフを伴います。自動運転の Closed-Loop では、「長期保存用の生データ」「学習・評価用の正規化データ」「可視化・デバッグ用のプレビュー」といった用途ごとに圧縮ポリシーを分けて設計することが多いです。

### 画像データの圧縮（カメラ）

カメラデータは、ロガー側では H.264 / H.265 (HEVC) などの動画コーデックでエンコードされたストリームとして保存されることが多いです。帯域・ストレージ効率に優れる一方で、ランダムアクセスやフレーム単位の再利用には向かない側面があります。そのため、クラウド側での正規化では、用途に応じて次のような戦略が考えられます。

- **長期アーカイブ**: ロガー出力そのまま（H.264/H.265 など）を Drive 単位で保存し、再エンコードによる情報損失を防ぐ。将来、より高品質なデコードやスーパーレゾリューション手法を適用する余地を残す。  
- **学習用静止画**: `ffmpeg` などを用いてフレーム抽出し、JPEG / PNG / WebP などの静止画フォーマットに変換する。JPEG は非可逆だがデコードが高速で実装も容易なため、現在も多くの学習パイプラインで利用されています。高ダイナミックレンジや低アーチファクトが重要な場合は、可逆 PNG や EXR を用いる場合もあります。  
- **プレビュー用**: 可視化・デバッグ用には、解像度を落とした JPEG や低ビットレートの MP4 を別途生成し、データブラウザから高速にストリーミングできるようにする。

新しい静止画コーデック（JPEG XL, AVIF など）は圧縮効率に優れますが、実運用ではデコーダのエコシステム（GPU デコード対応、ブラウザ互換性など）も考慮する必要があります。Closed-Loop の観点では、「学習・評価用データはデコードパスが安定している標準フォーマットに揃え、実験条件を変えない」ことが、再現性と比較のしやすさの面で重要です。

### 点群データの圧縮（LiDAR）

LiDAR 点群は、1 フレームあたり数十万〜数百万点を含むことが多く、素朴なバイナリ格納ではファイルサイズが急速に増大します。代表的な圧縮の選択肢としては、次のようなものがあります。

- **LAS / LAZ**: 地理情報分野で広く用いられる LAS フォーマットと、その可逆圧縮版である LAZ。LASzip / LAStools などのツール群で読み書きでき、点群属性（強度・分類・時間など）も保持しやすい形式です。大規模 LiDAR データの長期保存や交換フォーマットとして適しています。  
- **PCD / PLY + 汎用圧縮**: Point Cloud Library (PCL) などで扱いやすい PCD、または汎用 3D フォーマットである PLY を用い、ファイル自体を zstd / gzip / lz4 などで圧縮する方法です。実装が単純で、多くのツールチェーンと互換性があります。  
- **カスタムバイナリ + 圧縮**: 自動運転向けには、(x, y, z, intensity, ring, time) のようなフィールドを固定長バイナリ配列として並べ、ファイル全体を zstd 等で圧縮する構成もよく採用されます。レイアウトを固定することで、GPU 上でのデコード・前処理を高速に行いやすくなります。

圧縮方式の選択では、「ランダムアクセス vs 連続アクセス」「可逆 vs 非可逆」「デコードパスの実装容易性」といった観点をバランスさせる必要があります。学習・評価用の正規化データとしては、「ビットレートは多少増えても可逆に近い形で保持する」ことが多く、長期的には新しいモデル・タスクに対して再利用できるようにしておくと Closed-Loop の柔軟性が高まります。

### CAN / 車両バスログの圧縮

CAN バスやその他の車両ネットワーク（LIN, FlexRay, Ethernet など）のログは、テキスト（CSV, ASCII）形式・バイナリ形式（MDF4 / MF4, BLF, ASC など）で記録されることが多いです。  
これらは基本的に「高頻度のスカラー時系列」であり、画像・点群と比べると 1 レコードあたりのサイズは小さいものの、フリート全体では膨大な総量になります。

クラウド側では、次のような戦略が考えられます。

- **長期保存**: ロガーが出力するバイナリフォーマット（例: MDF4）をそのまま Drive 単位で保存し、ベンダーツールやオープンソースライブラリ（例: `asammdf` など）で解析する。  
- **分析・学習用**: CAN 信号を展開し、正規化されたチャンネル名・物理単位・スケーリングを付与したうえで、列指向フォーマット（Parquet）や時系列データベース（TimeScaleDB, InfluxDB 等）に変換する。この際、zstd / lz4 などの汎用圧縮を利用する。  
- **プレビュー・トレース用**: 一部の重要チャンネル（速度、加速度、操舵角、ブレーキ圧など）だけを抽出し、PlotJuggler や Web ベースのプロットツールで可視化しやすい CSV / JSON 形式も併用する。

特に、Closed-Loop のフィードバックでは、「どのタイミングで人間ドライバが介入したか」「どのような制御コマンドが出ていたか」といった車両バス情報が、安全分析・モデル改善の両面で重要になります。そのため、CAN ログの正規化と圧縮は、単なるストレージ節約ではなく、後段の分析容易性を担保するための設計だと考えた方がよいです。

### 汎用圧縮アルゴリズムの選択（gzip / zstd / lz4 など）

最後に、汎用圧縮アルゴリズムの選択について整理します。多くのシステムでは、次のようなアルゴリズムが使われています。

- **gzip**: 歴史が長く互換性が高いものの、圧縮・展開速度はやや遅め。既存ツールとの互換性が重要な場合に採用されることが多いです。  
- **zstd (Zstandard)**: 近年広く採用されているアルゴリズムで、圧縮率と速度のバランスが良いとされます。ROS 2 の rosbag2 圧縮、各種ログ収集システム、オブジェクトストレージ上のパーケットなどでも用いられています。  
- **lz4**: 非常に高速な圧縮・展開が可能で、圧縮率はそこそこ、という位置付けです。オンライン推論やリアルタイム系コンポーネントのログ圧縮に採用されることが多いです。

自動運転における Closed-Loop では、以下のように使い分けるパターンが考えられます。

- 長期保存用の生データや解析用パーケットには、zstd を採用し、ストレージコストとデコード速度のバランスを取る。  
- 学習用シャード（WebDataset など）は、I/O バインドになりやすい場合は zstd、CPU バインドになりやすい場合は lz4 など、実験しながら決める。  
- ログ収集基盤やオンラインモニタリングでリアルタイム性が重視される部分では、lz4 など軽量な圧縮を選択するか、場合によっては無圧縮とする。

いずれの場合も、「どのデータがどの圧縮方式・バージョンで保存されているか」をメタデータとして記録し、将来の再処理やフォーマット移行（例: zstd レベル変更、別コーデックへの再エンコード）に備えることが重要です。圧縮方式の変更も、Closed-Loop の一部として「性能・コスト・安全性への影響」を評価しながら進めるべき設計項目の一つだと考えられます。

