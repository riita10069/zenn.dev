---
title: "4.5 フォーマット変換／リサンプリング／特徴量抽出"
---

# 4.5 フォーマット変換／リサンプリング／特徴量抽出

この節では、学習・評価に適したデータ表現を得るためのフォーマット変換 (format conversion)、リサンプリング (resampling)、特徴量抽出 (feature extraction) について解説します。画像サイズ・フレームレートの統一、点群ダウンサンプリング・BEV / voxel 投影、光フロー・マスクなどの事前計算特徴を例に、データ中心・Closed-Loop の観点から「前処理にどこまで計算を寄せるか」「どの表現を標準フォーマットとして採用するか」を考えます。

## 画像・点群の正規化とリサンプリング

異なるセンサー構成や解像度・フレームレートのログを統一的に扱うため、以下のような処理を行うことが多いです。

- 画像解像度の統一とアスペクト比の扱い（パディング vs クロップ）。
- フレームレートの統一（例: 30fps にリサンプリング）とシーンの時間長の調整。
- 点群のダウンサンプリング、グリッド化、voxel / BEV 投影。

画像については、GPU メモリ制約やネットワークアーキテクチャの都合から、固定解像度（例: 800×448, 1600×900 等）にリサイズすることが一般的です。その際、アスペクト比を維持したパディングと、クロップによる情報損失のトレードオフを検討します。マルチカメラ構成では、カメラごとの内部パラメータ・外部パラメータを保持した上で、画像サイズを統一することが重要です。

点群については、以下のような手法が広く利用されています。

- Voxelization：3D 空間をボクセルグリッドに分割し、各ボクセル内の点の統計量（平均・最大反射強度など）を特徴として用いる。
- BEV 投影：地面に垂直な方向から見た鳥瞰図 (Bird's Eye View) 表現に変換し、2D 畳み込みで処理しやすくする。
- Range View 表現：LiDAR の走査角度と距離に基づき、距離画像のような 2D 表現に変換する。

これらの変換は、オンライン推論時にも必要になるため、学習データ作成時点で「推論時と同じ前処理チェーン」を定義し、コードとして一元管理することが望ましいです。

## 標準データフォーマットとストレージ設計

複数のタスクやモデルで共通に利用するデータセットを設計する場合、「標準データフォーマット」を定義しておくと、フォーマット変換の重複を減らせます。代表的な選択肢としては、

- Key-Value 形式のシャーディング（WebDataset, TFRecord など）。
- 列指向フォーマット（Apache Parquet, Arrow Dataset など）。
- HDF5 / Zarr 等の科学計算向けフォーマット。

があります。自動運転ログのようなマルチモーダル・時系列データでは、「シーン単位」「フレーム単位」「オブジェクト単位」のどの粒度でデータを格納するかも重要な設計要素です。例えば、

- シーン単位のシャード：一つのファイルに数十秒のデータをまとめて格納し、シミュレーションや Closed-Loop 評価に向いた形にする。
- フレーム単位のシャード：フレームごとに画像・点群・ラベルをまとめ、Perception モデルのミニバッチ構成をしやすくする。

といった方針が考えられます。ツールとしては、Python から簡便に読み書きできるフォーマットを選びつつ、分散処理基盤（Spark, Dask 等）との相性も考慮します。

## 事前計算特徴の抽出

一部の計算を前処理に寄せ、学習時の負荷を軽減する設計も一般的です。

- 光フロー (optical flow) やオプティカルフロー類似の動き特徴。
- セマンティックマスクやドライブブルゾーンなどの補助ラベル。
- マップベースの特徴（レーン中心線との距離、制限速度など）。

事前計算特徴の設計では、

- 「その特徴を前処理で計算しておくべきか」「モデル内部で end-to-end に学習させるべきか」
- 「特徴の計算コスト」と「精度向上・学習安定性」

のトレードオフを検討します。例えば、光フローは計算コストが高いため、学習時に毎回計算するよりも、前処理ジョブで計算してキャッシュしておく方が現実的な場合が多いです。一方で、自己教師あり学習のように「生の画像から動きを学習したい」場合は、明示的な光フローは不要かもしれません。

マップベースの特徴についても、オフラインで道路中心線や制限速度・一時停止位置との距離などを事前計算しておくことで、学習時のオンラインマップクエリを減らせます。HD マップとの結合は、ローカライゼーション結果や GNSS/IMU のポーズを用いるため、時刻同期・座標系変換（第 3 章）が正しく行われていることが前提になります。

## 前処理のバージョン管理と再現性

Closed-Loop の観点では、前処理の結果もバージョン管理し、モデル性能への影響をトレースできるようにすることが重要です。実務では、

- データスキーマに「前処理バージョン」「特徴量セットバージョン」といったフィールドを追加する。
- フォーマット変換・リサンプリング・特徴量抽出のコードを、学習コードと同じリポジトリまたは隣接リポジトリで管理する。
- データセットバージョン管理ツールやメタデータストアに、「どのデータセットがどの前処理バージョンを用いて作られたか」を記録する。

といった工夫が行われます。これにより、前処理パイプラインに修正が入ったときでも、旧バージョンのモデルを評価・再現できるようになります。

## 前処理パイプラインを支えるツールと実装パターン

フォーマット変換・リサンプリング・特徴量抽出を大規模に回すためには、以下のようなツールと実装パターンが有効です。

- 分散処理フレームワーク：Spark / Dask / Ray 等を用いて、数万〜数十万シーン規模の前処理ジョブを並列実行する。
- ワークフローオーケストレータ：Airflow, Luigi, Dagster 等で、前処理パイプラインを DAG として定義し、失敗時のリトライや再実行を自動化する。
- ストリーミング / オンライン処理：一部の簡易前処理（圧縮・簡単な正規化など）はオンボードやエッジ側で行い、クラウド側の負荷を下げる。

ツール選定にあたっては、特定プロダクトに依存し過ぎず、「バッチ処理」「ストリーミング処理」「GPU アクセラレーション」のバランスを見ながら構成を決めることが重要です。自動運転の前処理パイプラインは長期にわたり運用されるため、シンプルで保守しやすい構成を優先することが多いです。

